% -*- mode: Noweb; noweb-code-mode: python-mode -*-

\documentclass{amsart}

\usepackage{graphicx,noweb,fullpage}

\begin{document}

@

\author{Dave Schneider}
\address{Plant-Microbe Interaction Research Unit\\
  R.W.\ Holley Center \\
  USDA Agricultural Research Service \\
  538 Tower Road \\ Ithaca, NY 14583}

\email{Dave.Schneider@ars.usda.gov}

\title[Initial value problems for balance laws]{Initial value
  problems specified by systems of balance laws}

\begin{abstract}
Initial value problems of partial differential equations describing
flows involving diffusion and/or advection processes occur in many
contexts in science and engineering.  If sources or reactions are also
present, then the composition or amount of material being modeled can
change over time.  This note summarizes some of the most basic
mathematical and computional aspects of unsteady flows specified
balance laws in divergence form
\begin{displaymath}
  \frac{\partial u}{\partial t} + \frac{\partial F}{\partial x} = S(u,
  x, t)
\end{displaymath}
where $u$ is a density (assumed positive), $F$ defines the
associated fluxes, and $S$ is a source term that describes production,
loss or transformation of the entities under consideration.
Particular attention is paid to semilinear problems where
the flux term is a linear operator so that any nonlinear effects 
are due to the structure of the source term.  
\end{abstract}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:intro}

Initial value problems of partial differential equations describing
flows involving diffusion and/or advection processes occur in many
contexts in science and engineering.  If sources or reactions are also
present, then the composition or amount of material being modeled can
change over time.  This note summarizes some of the most basic
mathematical and computional aspects of unsteady flows specified
balance laws in divergence form
\begin{equation}
  \frac{\partial u}{\partial t} + \frac{\partial F}{\partial x} = S(u,
  x, t)
  \label{eq:balance_law_divergence_form}
\end{equation}
where $u$ is a density (assumed positive), $F$ defines the
associated fluxes, and $S$ is a source term that describes production,
loss or transformation of the entities under consideration.
Particular attention is paid to semilinear problems where
the flux term is a linear operator so that any nonlinear effects 
are due to the structure of the source term.

Most unsteady problems are semilinear and are either parabolic or
hyperbolic in nature, depending on the form of the flux term.  For
example, advective balance equation
\begin{equation}
  \frac{\partial u}{\partial t} + \frac{\partial \rho u}{\partial x} =
  \sigma
  \label{eq:advective_balance}
\end{equation}
and the telegrapher's equation
\begin{equation}
  \frac{\partial}{\partial t} \begin{pmatrix} u \\ v \end{pmatrix} + 
  \frac{\partial}{\partial x} \begin{pmatrix}  0 & - \alpha \\ -\alpha
    & 0 \end{pmatrix}\begin{pmatrix} u \\ v\end{pmatrix} =
    \begin{pmatrix}  0 \\ -2\beta v \end{pmatrix}
    \label{eq:telegrapher}
\end{equation}
are hyperbolic assuming $\rho, \alpha \ne 0$.  In contrast,
advection-reaction-diffusion equations
\begin{equation}
  \frac{\partial u}{\partial t} + \frac{\partial}{\partial x}
  \left(cu -D \frac{\partial u}{\partial x}\right) = S(u)
  \label{eq:advection_reaction_diffusion}
\end{equation}
are parabolic.

An obvious question is whether the solutions to
Equation~\ref{eq:advection_reaction_diffusion} somehow approach those
of Equation~\ref{eq:advective_balance} as $D\rightarrow 0$ provided
$c=\rho$.  In fact, under appropriate hypotheses the solutions to the
two equations do converge and the analysis offers considerable insight
into the numerical solution of Equation~\ref{eq:advective_balance} by
finite difference methods.  Similar arguments can be made about
Equation~\ref{eq:telegrapher}
and~\ref{eq:advection_reaction_diffusion} if $c=0$, $\alpha
\rightarrow \infty$ and $\beta \rightarrow \infty$ subject to the
constraint that $\beta^2/2\alpha = D$ is constant.

@ 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Source code}
\label{app:source_code}

The following Python~\cite{Python:2016} source code files and
associated documentation can be generated from this
file using [[notangle]] and [[noweave]],
respectively.~\cite{Ramsey:1994,JohnsonJohnson:1997}.

<<*>>=
<<TransportPDECauchy.py>>
<<AdvTransport1D.py>>
<<DiffTransport1D.py>>

@

% ------------------------------

\subsection{Coding standards}
\label{ssec:coding_standards}

The Python Developers Guide for Python Code (PEP
0008)~\cite{PEP0008:2016} contains many suggestions for formatting
source code, version control, naming conventions, and general
programming recommendations.  Some of these recommendations cannot be
easily applied or enforced in a literate programming environment.  On
the other hand, some tasks become very simple.

PEP 0008 suggests that documentation strings be provided for each
method so users can obtain information interactively by invoking the
[[help()]] function in the interpreter.  This will be done below.

%------------------------------

\subsection{Overview of the [[TransportPDECauchy]] base class}
\label{ssec:overview_TransportPDECauchy}

[[TransportPDECauchy]] is an base class that encapsulates
the implementation of the various terms in the PDE and associated
initial conditions.  Classes which implement specific PDEs should be
derived from this class (see below).

<<TransportPDECauchy.py>>=
<<Header>>
<<Import libraries>>

class TransportPDECauchy(object):
    """An base class for abstract Cauchy problems involving
    multicomponent balance laws.
    """
      
    <<Structural initialization>>
    <<Impose initial conditions>>
    <<Get density on grid>>
    <<Get flux on grid>>
    <<Get source on grid>>

@

PEP 0008 recommends a particular ordering of documentation strings, versioning
information, etc.\ at the top of the file.

<<Header>>=
<<Disclaimer>>

__version__ = '{0}.{1}'.format(0, 1)

<<Expose public programming interface>>

@

%------------------------------

\subsection{Public domain notice and disclaimer}
\label{ssec:disclaimer}

\input{Disclaimer.nw}

@

PEP 0008 also recommends that imports from the standard
libraries~\cite{PythonStandardLibrary:2016} precede those from third
parties.

<<Import libraries>>=
<<Import standard libraries>>
<<Import third party libraries>>

@

The numerical solution is computed via finite difference methods
on a uniform grid using the NumPy library~\cite{NumPy:2015}.  So, it
makes sense to use NumPy arrays to store data and as return values.

<<Import third party libraries>>=
import numpy as np

@ 

PEP 0008 also suggests exposing the public portions of the programming
interface by setting the [[__all__]] attribute.  This construction
defines what is imported when the library is imported with the
statement [[from TransportPDECauchy import *]].  The NumPy library
really is an integral part of the implementation, and exposing it here
obviates the need for the user to import it separately.

<<Expose public programming interface>>=
__all__ = ['TransportPDECauchy', 'np']

@

Initialization of an [[TransportPDECauchy]] instance requires a
user-supplied grid in the form of a NumPy array and, optionally a
means to define the initial density profile on that grid and a textual
description.  If the initial conditions are supplied, the density is
initialized by a call to the [[initial_conditions()]] method.  If not,
the user must call the [[initial_condition()]] method prior to
commencing integration.

<<Structural initialization>>=
def __init__(self, grid, ic=None, description=None):
    """Generic initialization"""
    self.description = description
    self.__grid = grid
    if ic is None:
        self.__density = None
    else:
	self.initial_condition(ic)

@

Other classes must also access the computational grid.  For example, the 
visualization methods of the [[Integrator]] class.

<<Get grid>>=
def grid(self):
    # return a copy of the grid
    return np.copy(self.__grid)

@

The user can specify initial conditions in several ways, including a
lambda function.  Since the initialization process depends on the way
the conditions are specified, it is necessary to check the argument
types.  There is no simple way of accessing the type of a lambda
function without using the standard [[types]] library.

<<Import standard libraries>>=
import types
    
<<Impose initial conditions>>=
def initial_condition(self, ic):
    if type(ic) == types.LambdaType or type(ic) == types.FunctionType:
       self.__density = np.array([ic(x, 0) for x in self.__grid], dtype=np.float)
    elif isinstance(ic, list) or isinstance(ic, tuple):
       self.__density = np.array(ic, dtype=np.float)
    elif isinstance(ic, np.array):
       self.__density = ic
    else:
       msg = 'Don\'t know how to initialize density from type {0}'
       raise NotImplementedError(msg.format(type(ic)))

@

The density is computed at the grid points and stored.

<<Get density on grid>>=
def density(self):
    """Return the density at each grid point"""
    
    assert(self.__density is not None)
    return np.copy(self.__density)

@

The actual computation of fluxes on the grid must be implemented in
derived classes. 

<<Get flux on grid>>=
def flux(self):
    """Abstract method for evaluating fluxes"""
    
    msg = 'flux() method must be overridden in derived classes'
    raise NotImplementedError(msg)

@

The computation of the sources must also be implemented in derived
classes, if present.

<<Get source on grid>>=
def source(self, t = None):
    """By default, sources are considered absent.  This method should be 
    overridden in derived classes if sources are present.
    """
    
    return np.zeros_like(self.__density)	

@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Derived classes describing specific equations}

%------------------------------

\subsection{Advective transport equation}
\label{ssec:advective}

The advective balance equation 
\begin{equation}
  \frac{\partial u}{\partial t} + \frac{\partial \rho u}{\partial x} =
  \sigma
  \label{eq:advective_transport_1D_inhomogeneous_PDE}
\end{equation}
provides an important benchmark for numerical work
because it has has very simple exact
solution~\cite[pp.\ 18-19]{Evans:1998}.  Indeed, if $\rho$ is a
positive real constant and $u(x, 0) = g(x)$ 
then
\begin{equation}
  u(x, t) = g(x-\rho t) + \int_{0}^{t} \sigma\left(x+\rho(s-t)\right)
  \; ds
  \label{eq:advective_transport_1D_inhomogeneous_solution}  
\end{equation}
if $\sigma$ is a sufficiently well behaved function of $x$ or $t$.

The form of this exact solution reveals why this superficially simple
problem is so hard to approximate numerically.  The first term can be
interpreted as a pulse or wave with a shape defined by the initial
conditions that propagates at a finite speed without damping or
distortion.  Said another way, there are plane wave solutions to the
homogeneous equation
\begin{equation}
  \frac{\partial w}{\partial t} + \frac{\partial c w}{\partial x} = 0
  \label{eq:advective_transport_1D_homogeneous_PDE}
\end{equation}
To verify this, insert the function $w(x, t) =
\exp\left[i(kx-\omega)t\right]$
into Equation~\ref{eq:advective_transport_1D_homogeneous_PDE} to obtain
\begin{equation}
  \left(\frac{\partial}{\partial t} + c\frac{\partial}{\partial
    x}\right) w = i(ck-\omega)w 
\end{equation}
Note, the right hand side vanishes if $\omega = ck$ so that $w$ represents
an undamped wave with phase velocity
\begin{equation}
  v_p = \omega/k = c
\end{equation}
and group velocity
\begin{equation}
  v_g = \frac{d\omega}{dk} = c
\end{equation}

These quantities $v_p$ and $v_g$ turn out to be very important in
understanding the behavior of the numerical solution of initial value
problems for dispersive partial differential equations~\footnote{Those
  with plane wave solutions involving frequency-dependent wave
  numbers.} obtained using finite difference
methods~\cite{Trefethen:1982}.  In general, one expects solutions with
uniformly propagating wave fronts to move at the group velocity at
long times.  However, one of the most basic difficulties with typical
finite difference schemes is the introduction of an artificial
frequency-dependent attenuation of plane waves.  This damping is
typically pronounced at high frequencies, leading to smearing of wave
fronts and other sharp features at long times.
        
<<AdvTransport1D.py>>=
<<Disclaimer>>

__version__ = '{0}.{1}'.format(0, 0)

from TransportPDECauchy import *

class AdvTransport1D(TransportPDECauchy):
    """Simple linear advective transport in 1D w/o sources"""
    
    def __init__(self, grid, ic, Peclet):
    	super(AdvTransport1D, self).__init__(grid = grid, ic = ic)
        self.Peclet = Peclet

    def flux(self):
        return self.Peclet*np.copy(self.__density)

    def source(self, t):
        return np.zeros_like(self.__density)

@

%------------------------------        

\subsection{Simple diffusion equation}
\label{ssec:diffusion}

<<DiffTransport1D.py>>=
<<Disclaimer>>

__version__ = '{0}.{1}'.format(0, 0)

from TransportPDECauchy import *

class DiffTransport1D(TransportPDECauchy):
    """Simple linear diffusive transport in 1D w/o sources"""
    
    def __init__(self, grid, ic, D):
    	super(DiffTransport1D, self).__init__(grid = grid, ic = ic)
        self.D = D

    def flux(self):
        return (-self.D*np.copy(self.__density[0]), -self.D*np.copy(self.__density[1]))

    def source(self, t):
        return np.zeros_like(self.__density)

@

%------------------------------        

\subsection{Advection-diffusion equation}
\label{ssec:advection_diffusion}

%------------------------------

\subsection{Fisher-Kolmogorov-Petrovsky-Piscounov equation}
\label{ssec:FKPP}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\bibliographystyle{unsrt}
\bibliography{TransportPDE}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}


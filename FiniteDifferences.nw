% -*- mode: Noweb; noweb-code-mode: python-mode -*-

\documentclass{amsart}

\usepackage{graphicx,noweb,fullpage}

\includeonly{Disclaimer,FDTest,FDCoefficients}

\begin{document}

@

\author{Dave Schneider}
\address{Plant-Microbe Interaction Research Unit\\
  R.W.\ Holley Center \\
  USDA Agricultural Research Service \\
  538 Tower Road \\ Ithaca, NY 14583}

\email{Dave.Schneider@ars.usda.gov}

\title[Finite difference methods]{Finite difference methods in Python}

\begin{abstract}
Finite difference methods are attractive methods for solving some
classes of partial differential equations.  
\end{abstract}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:intro}

The solution of ordinary and partial differential equations by finite
difference methods involves approximating the derivatives of functions
from the function values at grid points.  Given the values of $f:
\mathbb{R} \rightarrow \mathbb{R}$ at grid points
\begin{equation}
 \mathbf{X} = \left\{\ldots, x_{-4}, x_{-3}, x_{-2}, x_{-1}, x_{0}, x_{1}, x_{2},
  x_{3}, x_{4}, \ldots\right\}
\end{equation}
the derivatives of $f$ are approximated as
\begin{equation}
  \left.\frac{d^kf}{dx^k}\right|_{x=x_{0}} =
  \sum_{\nu=0}^{n} c^{k}_{n, \nu} f(x_{\nu}) + \mathcal{O}\left(\Delta
  x^{k-n+1}\right)
  \label{eq:fd_approx_deriv}
\end{equation}
The coefficients are tabulated in many places, including the text by
Fornberg~\cite{Fornberg:1998a} which includes a wealth of theoretical
insight into the behavior of the finite difference methods and
practical guidance on their implementation.  More details can be found
in other works by the same author~\cite{Fornberg:1988,
  Fornberg:1998b}.

Attention here will be limited to differential equations defined on
closed intervals of the real line so that conditions on the function
and/or its derivatives must be specified at the end points of the
interval in order to properly define the domain of the differential
operator being discretized.  Three different classes of boundary
conditions will be treated here
\begin{itemize}
  %
\item Periodic -- enforcement of periodicity of functions with period
  equal to the length of the interval
  %
\item Dirichlet -- specification of the value of a function at the
  end point
  %
\item Neumann -- specification of the value of a derivative of
  function at an end point
  %
\end{itemize}

In all cases, the matrix representations of one dimensional finite
difference operators have a natural Toeplitz
structure~\cite{HornJohnson:1985} where the coefficients in
Equation~\ref{eq:fd_approx_deriv}) appear along diagonals.
A Toeplitz matrix has the form
\begin{equation}
  A_N =
  \begin{pmatrix}
    a_{0}  & a_{1}  & a_{2} & \ldots & a_{N-2} & a_{N-1} \\
    a_{-1} & a_{0}  & a_{1} & \ldots & a_{N-3} & a_{N-2} \\
    a_{-2} & a_{-1} & a_{0} & \ldots & a_{N-4} & a_{N-3} \\
    \vdots & \vdots & \ddots & \ddots & \ddots & \vdots \\
    a_{-n+1} & a_{-n+2} & a_{-n+3} \cdots & a_{-1} & a_{0} 
  \end{pmatrix}
\end{equation}

Two special Toeplitz matrices will be used to organize the
presentation.  The first matrix, $L_N$, has zeros everywhere except
the first superdiagonal where it has unit entries,
\begin{equation}
  L_{N} = \begin{pmatrix}
    0 & 1 & 0 & \ldots & 0 \\
    0 & 0 & 1 & & \vdots \\
    \vdots & \ddots & \ddots & \ddots & 0 \\
    0 & 0 & \ddots & 0 & 1 \\
    0 & 0 & \ldots & 0 & 0
    \end{pmatrix}
\end{equation}
It is easy to verify that $J_{N}$ represents a left shift of a
sequence of elements; the first element is replaced by the second and
so forth until the last element is replaced by zero.  The second
Toeplitz matrix, $C_{N}$, differs from $L_{N}$ by the insertion of a
unit element in the extreme lower left corner
\begin{equation}
  C_{N} = \begin{pmatrix}
    0 & 1 & 0 & \ldots & 0 \\
    0 & 0 & 1 & & \vdots \\
    \vdots & \ddots & \ddots & \ddots & 0 \\
    0 & 0 & \ddots & 0 & 1 \\
    1 & 0 & \ldots & 0 & 0
  \end{pmatrix}
  \label{eq:cyclic_left_shift_def}
\end{equation}
Again, it is easy to verify that $C_{N}$ implements a $cyclic$ left
permutation; the first element is moved to the last position, the second is
moved to the first, the third to the second, and so forth.  Squaring
$C_{N}$ implements a cyclic shift by two elements
\begin{equation}
  C^{2}_{N} = \begin{pmatrix}
    0 & 0 & 1 & 0 & \ldots & 0 \\
    0 & 0 & 0 & 1 & & \vdots \\
    \vdots & \ddots & \ddots & \ddots & 1 \\
    1 & 0 & \ddots & 0 & 0 \\
    0 & 1 & \ldots & 0 & 0
  \end{pmatrix}
  \label{eq:cyclic_left_shift_squared}
\end{equation}
Iterating this process reveals $C^{N}_{N} = I_{N}$; $N$ cyclic left
permutations of an $N$-element sequence returns all elements back to
their original locations.

Straightforward manipulations also show that the transpose
$J_{N}^{\text{tr}}$ implements right shifts, and similarly
$C_{N}^{\text{tr}}$ implements cyclic right shifts.  A cyclic left
shift followed by a cyclic right shift again returns all elements to
their original location, i.e.,
\begin{equation}
  C_{N}^{\text{tr}}C_N = I_{N} = C_NC_{N}^{\text{tr}}
  \label{eq:CtransposeC}
\end{equation}
In contrast,
\begin{equation}
  J_{N}^{\text{tr}} J_{N} = I_{N} - e_0e_0^{\text{tr}}
  \label{eq:JtransposeJ}
\end{equation}
where $e_k^{\text{tr}}$ is the $k$ unit vector with a unit element at
position $k$ and zeros elsewhere.  This formula has a simple intuitive
interpretation -- the first element of the sequence is ``lost'' in the
application of $J_{N}$ and subsequent application of
$J_{N}^{\text{tr}}$ introduces a zero in its place and restores all of
the other elements to their original position.
  

The special class of Toeplitz matrices of
the form
\begin{equation}
A_{N} = \sum_{k=0}^{N-1} a_{k} C^{k}_{N}
\end{equation}
are called \emph{circulants} where, by convention, $C^{0}_{N} =
I_{N}$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Source code}
\label{sec:source_code}

A single Python~\cite{Python:2016} source code is produced

<<*>>=
<<FiniteDifferences.py>>

@

which contains definitions of two class, [[FiniteDifferences]] and
[[TestFiniteDifferences]], and a short main program.

<<FiniteDifferences.py>>=
<<Import standard libraries>>
<<Import third party libraries>>
<<Define public programming interface>>
<<[[FiniteDifferences]] class>>
<<Unit test framework>>
<<Main program to run unit tests>>

@

The [[FiniteDifferences]] class defines the entire public programming
interface.

<<Define public programming interface>>=
__all__ = ['FiniteDifferences']

@

The [[unittest]] module will be used to automate testing.  In
particular the [[TestFiniteDifferences]] class is derived from
[[unittest.TestCase]].

<<Import standard libraries>>=
import unittest

@

The coefficients for the finite difference operators are stored as
rational fractions~\cite{PythonStandardLibrary:2016} in dictionaries
indexed by integer offsets

<<Import standard libraries>>=
from gmpy2 import mpq

@ 

The finite difference operators themselves are represented using
SciPy~\cite{SciPy:2015} sparse matrices constructed by diagonals.

<<Import third party libraries>>=
from scipy.sparse import diags

@

Since the operators are stored as SciPy sparse matrices, it is natural to use
NumPy~\cite{NumPy:2015} arrays to store vectors.

<<Import third party libraries>>=
import numpy as np

@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{[[FiniteDifferences]] class}
\label{sec:finite_differences}

The [[FiniteDifferences]] class contains only class-level attributes.
Support is provided for both explicit and implicit schemes in one
dimension.  Implicit difference schemes require a matrix
representation of the finite difference operators while explicit
schemes require the only the action of the operator on vectors.


<<[[FiniteDifferences]] class>>=
class FiniteDifferences(object):
    <<Coefficients for one-sided FD approximations>>
    <<Coefficients for centered FD approximations>>
    <<Finite differences on periodic lattices>>
    <<Finite differences on nonperiodic lattices>>    

@ 

Explicit application of one-sided finite differences of data on
periodic lattices using cyclic permutations of vectors.

<<Finite differences on periodic lattices>>=
def periodic_one_sided_stencil(u, dorder, aorder=2):
    '''Apply one-sided stencil for derivative to vector (periodic)'''
    
    v = np.zeros_like(u)
    for offset, coeff in FiniteDifferences._osd[dorder, aorder].items():
	v += float(coeff)*np.roll(u, -offset)
    return v

@

Matrix representations of finite difference operators on periodic
lattices have a sparse circulant structure.  The offsets and
coefficients of the finite difference stencil are retrieved and
broadcasted along diagonals.  Coefficients with non-vanishing offsets
are used to create two separate diagonals to enforce periodicity.

<<Finite differences on periodic lattices>>=
def periodic_one_sided_op(N,  der_order, approx_order=2):
    '''Compute N-dimensional sparse matrix representation for 
       one-sided difference approximation (periodic)
    '''
    
    offsets = list()
    coeffs  = list()
    for offset, coeff in FiniteDifferences._osd[der_order, approx_order].items():
        offsets.append(offset)
        coeffs.append(float(coeff))
        if offset > 0:
            offsets.append(offset-N)
            coeffs.append(float(coeff))
    return diags(coeffs, offsets, shape=(N, N), dtype=np.float).tocsr()

@ 

Explicit application of centered finite differences of data on
non-periodic lattices using cyclic permutation of vectors.

<<Finite differences on periodic lattices>>=

def periodic_centered_stencil(u, dorder, aorder=2):
    '''Apply centered difference stencil to vector (periodic)'''
    
    v = np.zeros_like(u)
    for offset, coeff in FiniteDifferences._cd[dorder, aorder].items():
	v += float(coeff)*np.roll(u, -offset)
    return v

@

Matrix representations for centered finite difference operators on
periodic lattices also have a sparse circulant structure.
Coefficients with non-vanishing offsets create two separate diagonals
due to ``wrap around''.  In contrast to the one-sided case above,
offsets may be positive or negative, which are handled separately.

<<Finite differences on periodic lattices>>=

def periodic_centered_op(N,  der_order, approx_order=2):
    '''Compute N-dimensional sparse matrix representation 
       for centered difference approximation (periodic)
    '''
    
    offsets = list()
    coeffs  = list()
    for offset, coeff in FiniteDifferences._cd[der_order, approx_order].items():
        offsets.append(offset)
        coeffs.append(float(coeff))
        if not offset == 0:
            if offset > 0:
                offsets.append(offset-N)
            else:
                offsets.append(offset+N)
            coeffs.append(float(coeff))
    return diags(coeffs, offsets, shape=(N, N), dtype=np.float).tocsr()

@

Matrix representations of difference operators on non-periodic
lattices have a circulant structure, but lack the lower left and
upper right corners are empty that arise in the periodic case.

<<Finite differences on nonperiodic lattices>>=
def nonperiodic_one_sided_op(N,  der_order, approx_order=2):
    '''Compute N-dimensional sparse matrix representation for
       one-sided difference approximation (non-periodic)
    '''
    
    offsets = list()
    coeffs  = list()
    for offset, coeff in FiniteDifferences._osd[der_order, approx_order].items():
        offsets.append(offset)
        coeffs.append(float(coeff))
    return diags(coeffs, offsets, shape=(N, N), dtype=np.float).tocsr()

def nonperiodic_centered_op(N,  der_order, approx_order=2):
    '''Compute N-dimensional sparse matrix representation 
       for centered difference approximation (non-periodic)
    '''
    
    offsets = list()
    coeffs  = list()
    for offset, coeff in FiniteDifferences._cd[der_order, approx_order].items():
        offsets.append(offset)
        coeffs.append(float(coeff))
    return diags(coeffs, offsets, shape=(N, N), dtype=np.float).tocsr()

@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\include{Disclaimer}
\include{FDTest}
\include{FDCoefficients}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\bibliographystyle{unsrt}
\bibliography{TransportPDE}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

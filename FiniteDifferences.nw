% -*- mode: Noweb; noweb-code-mode: python-mode -*-

\documentclass{amsart}

\usepackage{graphicx,noweb,fullpage}

\includeonly{Disclaimer,FDTest,FDCoefficients}

\begin{document}

@

\author{Dave Schneider}
\address{Plant-Microbe Interaction Research Unit\\
  R.W.\ Holley Center \\
  USDA Agricultural Research Service \\
  538 Tower Road \\ Ithaca, NY 14583}

\email{Dave.Schneider@ars.usda.gov}

\title[Finite difference methods]{Finite difference methods in Python}

\begin{abstract}
Finite difference methods are attractive methods for solving some
classes of partial differential equations.  
\end{abstract}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{sec:intro}

The solution of ordinary and partial differential equations by finite
difference methods involves approximating the derivatives of functions
from the function values at grid points.  Given the values of $f:
\mathbb{R} \rightarrow \mathbb{R}$ at grid points
\begin{equation}
 \mathbf{X} = \left\{\ldots, x_{-4}, x_{-3}, x_{-2}, x_{-1}, x_{0}, x_{1}, x_{2},
  x_{3}, x_{4}, \ldots\right\}
\end{equation}
the derivatives of $f$ are approximated as
\begin{equation}
  \left.\frac{d^kf}{dx^k}\right|_{x=x_{0}} =
  \sum_{\nu=0}^{n} c^{k}_{n, \nu} f(x_{\nu}) + \mathcal{O}\left(\Delta x^{k-n+1}\right)
\end{equation}
The coefficients are tabulated in many places, including the text by
Fornberg~\cite{Fornberg:1998a} which includes a wealth of theoretical
insight into the behavior of the finite difference methods and
practical guidance on their implementation.  More details can be found
in other works by the same author~\cite{Fornberg:1988, Fornberg:1998b}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Source code}
\label{sec:source_code}

A single Python~\cite{Python:2016} source code is produced

<<*>>=
<<FiniteDifferences.py>>

@

which contains definitions of two class, [[FiniteDifferences]] and
[[TestFiniteDifferences]], and a short main program.

<<FiniteDifferences.py>>=
<<Import standard libraries>>
<<Import third party libraries>>
<<Define public programming interface>>
<<[[FiniteDifferences]] class>>
<<Unit test framework>>
<<Main program to run unit tests>>

@

The [[FiniteDifferences]] class contains only class-level attributes
and defines the entire public programming interface.

<<Define public programming interface>>=
__all__ = ['FiniteDifferences']

@

The [[unittest]] module will be used to automate testing.  In
particular the [[TestFiniteDifferences]] class is derived from
[[unittest.TestCase]].

<<Import standard libraries>>=
import unittest

@

The coefficients for the finite difference operators are stored as
rational fractions~\cite{PythonStandardLibrary:2016} in dictionaries
indexed by integer offsets

<<Import standard libraries>>=
from gmpy2 import mpq

@ 

The finite difference operators themselves are represented using
SciPy~\cite{SciPy:2015} sparse matrices constructed by diagonals.

<<Import third party libraries>>=
from scipy.sparse import diags

@

Since the operators are stored as SciPy sparse matrices, it is natural to use
NumPy~\cite{NumPy:2015} arrays to store vectors.

<<Import third party libraries>>=
import numpy as np

@

<<[[FiniteDifferences]] class>>=
class FiniteDifferences(object):
    <<Coefficients for one-sided FD approximations>>
    <<Coefficients for centered FD approximations>>
    <<Finite differences on periodic lattices>>
    <<Finite differences on nonperiodic lattices>>    

@ 

Explicit application of one-sided finite differences of data on
periodic lattices using cyclic permutations of vectors.

<<Finite differences on periodic lattices>>=
def periodic_one_sided_stencil(u, dorder, aorder=2):
    '''Apply one-sided stencil for derivative to vector (periodic)'''
    
    v = np.zeros_like(u)
    for offset, coeff in FiniteDifferences._osd[dorder, aorder].items():
	v += float(coeff)*np.roll(u, -offset)
    return v

@

Matrix representations of finite difference operators on periodic
lattices have a sparse circulant structure.  The offsets and
coefficients of the finite difference stencil are retrieved and
broadcasted along diagonals.  Coefficients with non-vanishing offsets
are used to create two separate diagonals to enforce periodicity.

<<Finite differences on periodic lattices>>=
def periodic_one_sided_op(N,  der_order, approx_order=2):
    '''Compute N-dimensional sparse matrix representation for 
       one-sided difference approximation (periodic)
    '''
    
    offsets = list()
    coeffs  = list()
    for offset, coeff in FiniteDifferences._osd[der_order, approx_order].items():
        offsets.append(offset)
        coeffs.append(float(coeff))
        if offset > 0:
            offsets.append(offset-N)
            coeffs.append(float(coeff))
    return diags(coeffs, offsets, shape=(N, N), dtype=np.float).tocsr()

@ 

Explicit application of centered finite differences of data on
non-periodic lattices using cyclic permutation of vectors.

<<Finite differences on periodic lattices>>=

def periodic_centered_stencil(u, dorder, aorder=2):
    '''Apply centered difference stencil to vector (periodic)'''
    
    v = np.zeros_like(u)
    for offset, coeff in FiniteDifferences._cd[dorder, aorder].items():
	v += float(coeff)*np.roll(u, -offset)
    return v

@

Matrix representations for centered finite difference operators on
periodic lattices also have a sparse circulant structure.
Coefficients with non-vanishing offsets create two separate diagonals
due to ``wrap around''.  In contrast to the one-sided case above,
offsets may be positive or negative, which are handled separately.

<<Finite differences on periodic lattices>>=

def periodic_centered_op(N,  der_order, approx_order=2):
    '''Compute N-dimensional sparse matrix representation 
       for centered difference approximation (periodic)
    '''
    
    offsets = list()
    coeffs  = list()
    for offset, coeff in FiniteDifferences._cd[der_order, approx_order].items():
        offsets.append(offset)
        coeffs.append(float(coeff))
        if not offset == 0:
            if offset > 0:
                offsets.append(offset-N)
            else:
                offsets.append(offset+N)
            coeffs.append(float(coeff))
    return diags(coeffs, offsets, shape=(N, N), dtype=np.float).tocsr()

@

Matrix representations of difference operators on non-periodic
lattices have a circulant structure, but lack the lower left and
upper right corners are empty that arise in the periodic case.

<<Finite differences on nonperiodic lattices>>=
def nonperiodic_one_sided_op(N,  der_order, approx_order=2):
    '''Compute N-dimensional sparse matrix representation for
       one-sided difference approximation (non-periodic)
    '''
    
    offsets = list()
    coeffs  = list()
    for offset, coeff in FiniteDifferences._osd[der_order, approx_order].items():
        offsets.append(offset)
        coeffs.append(float(coeff))
    return diags(coeffs, offsets, shape=(N, N), dtype=np.float).tocsr()

def nonperiodic_centered_op(N,  der_order, approx_order=2):
    '''Compute N-dimensional sparse matrix representation 
       for centered difference approximation (non-periodic)
    '''
    
    offsets = list()
    coeffs  = list()
    for offset, coeff in FiniteDifferences._cd[der_order, approx_order].items():
        offsets.append(offset)
        coeffs.append(float(coeff))
    return diags(coeffs, offsets, shape=(N, N), dtype=np.float).tocsr()

@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix

\include{Disclaimer}
\include{FDTest}
\include{FDCoefficients}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\bibliographystyle{unsrt}
\bibliography{TransportPDE}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
